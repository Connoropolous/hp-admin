"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.seedrand = seedrand;
exports.rand = rand;
exports.createColor = createColor;
exports.mixColors = mixColors;
exports.encodeColor = encodeColor;
exports.stringToBits = stringToBits;
exports.getBitStream = getBitStream;

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(getBitStream);

var randseed = new Array(4); // Xorshift: [x, y, z, w] 32 bit values

function seedrand(seed) {
  randseed.fill(0);

  for (var i = 0; i < seed.length; i++) {
    randseed[i % 4] = (randseed[i % 4] << 5) - randseed[i % 4] + seed.charCodeAt(i);
  }
}

function rand() {
  // based on Java's String.hashCode(), expanded to 4 32bit values
  var t = randseed[0] ^ randseed[0] << 11;
  randseed[0] = randseed[1];
  randseed[1] = randseed[2];
  randseed[2] = randseed[3];
  randseed[3] = randseed[3] ^ randseed[3] >> 19 ^ t ^ t >> 8;
  return (randseed[3] >>> 0) / (1 << 31 >>> 0);
}

function createColor() {
  //saturation is the whole color spectrum
  var h = Math.floor(rand() * 360); //saturation goes from 40 to 100, it avoids greyish colors

  var s = rand() * 60 + 40; //lightness can be anything from 0 to 100, but probabilities are a bell curve around 50%

  var l = (rand() + rand() + rand() + rand()) * 25;
  return {
    h: h,
    s: s,
    l: l
  };
}

function mixColors(a, b, amt) {
  return {
    h: a.h * (1 - amt) + b.h * amt,
    s: a.s * (1 - amt) + b.s * amt,
    l: a.l * (1 - amt) + b.l * amt
  };
}

function encodeColor(_ref) {
  var h = _ref.h,
      s = _ref.s,
      l = _ref.l;
  return "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)");
}

function stringToBits(string) {
  return Array.from(string).reduce(function (acc, _char) {
    return acc.concat(_char.charCodeAt().toString(2));
  }, []).map(function (bin) {
    return '0'.repeat(8 - bin.length) + bin;
  }).join('');
}

function getBitStream(string) {
  var bits, i;
  return regeneratorRuntime.wrap(function getBitStream$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          bits = stringToBits(string);
          i = 0;

        case 2:
          if (!(i < bits.length)) {
            _context.next = 8;
            break;
          }

          _context.next = 5;
          return parseInt(bits[i]);

        case 5:
          i++;
          _context.next = 2;
          break;

        case 8:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}