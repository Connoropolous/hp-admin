{"ast":null,"code":"import _defineProperty from \"/home/lisa/Documents/gitrepos/holochain/holo/happyTeam/hp-admin/hp-admin/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport _ from 'lodash';\nimport { mapValues } from 'lodash/fp';\nimport { instanceCreateZomeCall } from \"../holochainClient\";\nimport { TYPE, STATUS, DIRECTION } from 'models/Transaction';\nexport const currentDataTimeIso = () => new Date().toISOString();\nexport const INSTANCE_ID = 'holofuel';\nconst createZomeCall = instanceCreateZomeCall(INSTANCE_ID);\nconst MOCK_DEADLINE = '4019-01-02T03:04:05.678901234+00:00';\n\nconst presentRequest = ({\n  origin,\n  event,\n  stateDirection,\n  eventTimestamp,\n  counterparty,\n  amount,\n  notes,\n  fees\n}) => {\n  return {\n    id: origin,\n    amount: amount || event.Request.amount,\n    counterparty: counterparty || event.Request.from,\n    direction: stateDirection,\n    status: STATUS.pending,\n    type: TYPE.request,\n    timestamp: eventTimestamp,\n    notes: notes || event.Request.notes,\n    fees\n  };\n};\n\nconst presentOffer = ({\n  origin,\n  event,\n  stateDirection,\n  eventTimestamp,\n  counterparty,\n  amount,\n  notes,\n  fees\n}) => {\n  return {\n    id: origin,\n    amount: amount || event.Promise.tx.amount,\n    counterparty: counterparty || event.Promise.tx.to,\n    direction: stateDirection,\n    status: STATUS.pending,\n    type: TYPE.offer,\n    timestamp: eventTimestamp,\n    notes: notes || event.Promise.tx.notes,\n    fees\n  };\n};\n\nconst presentReceipt = ({\n  origin,\n  event,\n  stateDirection,\n  eventTimestamp,\n  fees,\n  presentBalance\n}) => {\n  const counterparty = stateDirection === DIRECTION.incoming ? event.Receipt.cheque.invoice.promise.tx.from : event.Receipt.cheque.invoice.promise.tx.to;\n  return {\n    id: origin,\n    amount: event.Receipt.cheque.invoice.promise.tx.amount,\n    counterparty,\n    direction: stateDirection,\n    status: STATUS.completed,\n    type: event.Receipt.cheque.invoice.promise.request ? TYPE.request : TYPE.offer,\n    // this indicates the original event type (eg. 'I requested hf from you', 'You sent a offer to me', etc.)\n    timestamp: eventTimestamp,\n    fees,\n    presentBalance,\n    notes: event.Receipt.cheque.invoice.promise.tx.notes\n  };\n}; // TODO: Review whether we should be showing this in addition to the receipt\n\n\nconst presentCheque = ({\n  origin,\n  event,\n  stateDirection,\n  eventTimestamp,\n  fees,\n  presentBalance\n}) => {\n  const counterparty = stateDirection === DIRECTION.incoming ? event.Cheque.invoice.promise.tx.from : event.Cheque.invoice.promise.tx.to;\n  return {\n    id: origin,\n    amount: event.Cheque.invoice.promise.tx.amount,\n    counterparty,\n    direction: stateDirection,\n    status: STATUS.completed,\n    type: event.Cheque.invoice.promise.request ? TYPE.request : TYPE.offer,\n    // this indicates the original event type (eg. 'I requested hf from you', 'You sent a offer to me', etc.)\n    timestamp: eventTimestamp,\n    fees,\n    presentBalance,\n    notes: event.Cheque.invoice.promise.tx.notes\n  };\n};\n\nfunction presentPendingRequest(transaction) {\n  const event = transaction.event,\n        provenance = transaction.provenance;\n  const origin = event[0];\n  const stateDirection = DIRECTION.incoming; // this indicates the recipient of funds\n\n  const eventTimestamp = event[1];\n  const counterparty = provenance[0];\n  const _event$2$Request = event[2].Request,\n        amount = _event$2$Request.amount,\n        notes = _event$2$Request.notes,\n        fee = _event$2$Request.fee;\n  return presentRequest({\n    origin,\n    stateDirection,\n    eventTimestamp,\n    counterparty,\n    amount,\n    notes,\n    fees: fee\n  });\n}\n\nfunction presentPendingOffer(transaction) {\n  const event = transaction.event,\n        provenance = transaction.provenance;\n  const origin = event[2].Promise.request ? event[2].Promise.request : event[0];\n  const stateDirection = DIRECTION.outgoing; // this indicates the spender of funds\n\n  const eventTimestamp = event[1];\n  const counterparty = provenance[0];\n  const _event$2$Promise$tx = event[2].Promise.tx,\n        amount = _event$2$Promise$tx.amount,\n        notes = _event$2$Promise$tx.notes,\n        fee = _event$2$Promise$tx.fee;\n  return presentOffer({\n    origin,\n    stateDirection,\n    eventTimestamp,\n    counterparty,\n    amount,\n    notes,\n    fees: fee\n  });\n}\n\nfunction presentTransaction(transaction) {\n  const state = transaction.state,\n        origin = transaction.origin,\n        event = transaction.event,\n        timestamp = transaction.timestamp,\n        adjustment = transaction.adjustment;\n  const stateStage = state.split('/')[1];\n  const stateDirection = state.split('/')[0]; // NOTE: This returns either 'incoming' or 'outgoing,' wherein, 'incoming' indicates the recipient of funds, 'outgoing' indicates the spender of funds.\n  // NOTE: *Holofuel does NOT yet provide a balance that represents the 'RESULTING ACCT BALANCE after this transaction adjustment', instead of the only the tx adjustment balance or real-time balance.*\n\n  const parsedAdjustment = mapValues('Ok', adjustment);\n\n  switch (stateStage) {\n    case 'completed':\n      {\n        if (event.Receipt) return presentReceipt({\n          origin,\n          event,\n          stateDirection,\n          eventTimestamp: timestamp.event,\n          fees: parsedAdjustment.fees,\n          presentBalance: parsedAdjustment.resulting_balance\n        });\n        if (event.Cheque) return presentCheque({\n          origin,\n          event,\n          stateDirection,\n          eventTimestamp: timestamp.event,\n          fees: parsedAdjustment.fees,\n          presentBalance: parsedAdjustment.resulting_balance\n        });\n        throw new Error('Completed event did not have a Receipt or Cheque event');\n      }\n\n    case 'rejected':\n      {\n        // We have decided not to return the reject case into the Ledger\n        break;\n      }\n    // The below two cases are 'waitingTransaction' cases :\n\n    case 'requested':\n      {\n        return presentRequest({\n          origin,\n          event,\n          stateDirection,\n          eventTimestamp: timestamp.event,\n          fees: parsedAdjustment.fees\n        });\n      }\n    // NOTE: 'approved' only indicates that a payment was offered (could be in response to a request or an isolate payment)\n\n    case 'approved':\n      {\n        return presentOffer({\n          origin,\n          event,\n          stateDirection,\n          eventTimestamp: timestamp.event,\n          fees: parsedAdjustment.fees\n        });\n      }\n\n    default:\n      throw new Error('Error: No transaction stateState was matched. Current transaction stateStage : ', stateStage);\n  }\n}\n\nconst HoloFuelDnaInterface = {\n  user: {\n    get: async ({\n      agentId\n    }) => {\n      const result = await createZomeCall('transactions/whoami')({\n        agentId\n      });\n      if (result.error) throw new Error('There was an error locating the agent nickname. ERROR: ', result.error);\n      return {\n        id: result.pub_sign_key,\n        nickname: result.nick\n      };\n    }\n  },\n  ledger: {\n    get: async () => {\n      const _ref = await createZomeCall('transactions/ledger_state')(),\n            balance = _ref.balance,\n            credit = _ref.credit,\n            payable = _ref.payable,\n            receivable = _ref.receivable,\n            fees = _ref.fees;\n\n      return {\n        balance,\n        credit,\n        payable,\n        receivable,\n        fees\n      };\n    }\n  },\n  transactions: {\n    allCompleted: async () => {\n      const _ref2 = await createZomeCall('transactions/list_transactions')(),\n            transactions = _ref2.transactions;\n\n      const listOfNonActionableTransactions = transactions.map(presentTransaction);\n\n      const noDuplicateIds = _.uniqBy(listOfNonActionableTransactions, 'id');\n\n      return noDuplicateIds.filter(tx => tx.status === 'completed').sort((a, b) => a.timestamp < b.timestamp ? -1 : 1);\n    },\n    allActionable: async () => {\n      const _ref3 = await createZomeCall('transactions/list_pending')(),\n            requests = _ref3.requests,\n            promises = _ref3.promises;\n\n      const actionableTransactions = requests.map(presentPendingRequest).concat(promises.map(presentPendingOffer));\n      return actionableTransactions.sort((a, b) => a.timestamp < b.timestamp ? -1 : 1);\n    },\n    allWaiting: async () => {\n      const _ref4 = await createZomeCall('transactions/list_transactions')(),\n            transactions = _ref4.transactions;\n\n      const listOfNonActionableTransactions = transactions.map(presentTransaction); // NOTE: Filtering out duplicate IDs should prevent an already completed tranaction from displaying as a pending tranaction if any lag occurs in data update layer.\n\n      const noDuplicateIds = _.uniqBy(listOfNonActionableTransactions, 'id');\n\n      return noDuplicateIds.filter(tx => tx.status === 'pending').sort((a, b) => a.timestamp < b.timestamp ? -1 : 1);\n    },\n    getSinglePending: async transactionId => {\n      const _ref5 = await createZomeCall('transactions/list_pending')({\n        origins: transactionId\n      }),\n            requests = _ref5.requests,\n            promises = _ref5.promises;\n\n      const transactionArray = requests.map(presentPendingRequest).concat(promises.map(presentPendingOffer));\n\n      if (transactionArray.length === 0) {\n        throw new Error(\"no pending transaction with id \".concat(transactionId, \" found.\"));\n      } else {\n        return transactionArray[0];\n      }\n    },\n    // decline pending proposed transaction (NB: proposed by another agent).\n    decline: async transactionId => {\n      const transaction = await HoloFuelDnaInterface.transactions.getSinglePending(transactionId);\n      await createZomeCall('transactions/decline')({\n        origin: transactionId\n      });\n      return _objectSpread({}, transaction, {\n        id: transactionId,\n        status: STATUS.rejected\n      });\n    },\n    // cancel pending authored transaction.\n    cancel: async transactionId => {\n      const transaction = await HoloFuelDnaInterface.transactions.getSinglePending(transactionId);\n      await createZomeCall('transactions/cancel')({\n        origin: transactionId\n      });\n      return _objectSpread({}, transaction, {\n        id: transactionId,\n        status: STATUS.cancelled\n      });\n    }\n  },\n  requests: {\n    create: async (counterparty, amount) => {\n      const origin = await createZomeCall('transactions/request')({\n        from: counterparty,\n        amount,\n        deadline: MOCK_DEADLINE\n      });\n      return {\n        id: origin,\n        amount,\n        counterparty,\n        direction: DIRECTION.incoming,\n        // this indicates the hf recipient\n        status: STATUS.pending,\n        type: TYPE.request,\n        timestamp: currentDataTimeIso\n      };\n    }\n  },\n  offers: {\n    create: async (counterparty, amount, requestId) => {\n      const origin = await createZomeCall('transactions/promise')({\n        to: counterparty,\n        amount,\n        deadline: MOCK_DEADLINE,\n        requestId\n      });\n      return {\n        id: requestId || origin,\n        // NOTE: If requestId isn't defined, then offer use origin as the ID (ie. Offer is the initiating transaction).\n        amount,\n        counterparty,\n        direction: DIRECTION.outgoing,\n        // this indicates the hf spender\n        status: STATUS.pending,\n        type: TYPE.offer,\n        timestamp: currentDataTimeIso\n      };\n    },\n    accept: async transactionId => {\n      const transaction = await HoloFuelDnaInterface.transactions.getSinglePending(transactionId);\n      await createZomeCall('transactions/receive_payments_pending')({\n        promises: transactionId\n      });\n      console.log('ACCEPT PAYMENT TRANSACTION OBJECT : ', transaction);\n      return _objectSpread({}, transaction, {\n        id: transactionId,\n        // direction: DIRECTION.incoming, // this indicates the hf recipient\n        status: STATUS.completed // ,\n        // type: TYPE.offer\n\n      });\n    }\n  }\n};\nexport default HoloFuelDnaInterface;","map":{"version":3,"sources":["/home/lisa/Documents/gitrepos/holochain/holo/happyTeam/hp-admin/hp-admin/src/data-interfaces/HoloFuelDnaInterface.js"],"names":["_","mapValues","instanceCreateZomeCall","TYPE","STATUS","DIRECTION","currentDataTimeIso","Date","toISOString","INSTANCE_ID","createZomeCall","MOCK_DEADLINE","presentRequest","origin","event","stateDirection","eventTimestamp","counterparty","amount","notes","fees","id","Request","from","direction","status","pending","type","request","timestamp","presentOffer","Promise","tx","to","offer","presentReceipt","presentBalance","incoming","Receipt","cheque","invoice","promise","completed","presentCheque","Cheque","presentPendingRequest","transaction","provenance","fee","presentPendingOffer","outgoing","presentTransaction","state","adjustment","stateStage","split","parsedAdjustment","resulting_balance","Error","HoloFuelDnaInterface","user","get","agentId","result","error","pub_sign_key","nickname","nick","ledger","balance","credit","payable","receivable","transactions","allCompleted","listOfNonActionableTransactions","map","noDuplicateIds","uniqBy","filter","sort","a","b","allActionable","requests","promises","actionableTransactions","concat","allWaiting","getSinglePending","transactionId","origins","transactionArray","length","decline","rejected","cancel","cancelled","create","deadline","offers","requestId","accept","console","log"],"mappings":"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","sourcesContent":["import _ from 'lodash'\nimport { mapValues } from 'lodash/fp'\nimport { instanceCreateZomeCall } from '../holochainClient'\nimport { TYPE, STATUS, DIRECTION } from 'models/Transaction'\n\nexport const currentDataTimeIso = () => new Date().toISOString()\n\nexport const INSTANCE_ID = 'holofuel'\nconst createZomeCall = instanceCreateZomeCall(INSTANCE_ID)\n\nconst MOCK_DEADLINE = '4019-01-02T03:04:05.678901234+00:00'\n\nconst presentRequest = ({ origin, event, stateDirection, eventTimestamp, counterparty, amount, notes, fees }) => {\n  return {\n    id: origin,\n    amount: amount || event.Request.amount,\n    counterparty: counterparty || event.Request.from,\n    direction: stateDirection,\n    status: STATUS.pending,\n    type: TYPE.request,\n    timestamp: eventTimestamp,\n    notes: notes || event.Request.notes,\n    fees\n  }\n}\n\nconst presentOffer = ({ origin, event, stateDirection, eventTimestamp, counterparty, amount, notes, fees }) => {\n  return {\n    id: origin,\n    amount: amount || event.Promise.tx.amount,\n    counterparty: counterparty || event.Promise.tx.to,\n    direction: stateDirection,\n    status: STATUS.pending,\n    type: TYPE.offer,\n    timestamp: eventTimestamp,\n    notes: notes || event.Promise.tx.notes,\n    fees\n  }\n}\n\nconst presentReceipt = ({ origin, event, stateDirection, eventTimestamp, fees, presentBalance }) => {\n  const counterparty = stateDirection === DIRECTION.incoming ? event.Receipt.cheque.invoice.promise.tx.from : event.Receipt.cheque.invoice.promise.tx.to\n  return {\n    id: origin,\n    amount: event.Receipt.cheque.invoice.promise.tx.amount,\n    counterparty,\n    direction: stateDirection,\n    status: STATUS.completed,\n    type: event.Receipt.cheque.invoice.promise.request ? TYPE.request : TYPE.offer, // this indicates the original event type (eg. 'I requested hf from you', 'You sent a offer to me', etc.)\n    timestamp: eventTimestamp,\n    fees,\n    presentBalance,\n    notes: event.Receipt.cheque.invoice.promise.tx.notes\n  }\n}\n\n// TODO: Review whether we should be showing this in addition to the receipt\nconst presentCheque = ({ origin, event, stateDirection, eventTimestamp, fees, presentBalance }) => {\n  const counterparty = stateDirection === DIRECTION.incoming ? event.Cheque.invoice.promise.tx.from : event.Cheque.invoice.promise.tx.to\n  return {\n    id: origin,\n    amount: event.Cheque.invoice.promise.tx.amount,\n    counterparty,\n    direction: stateDirection,\n    status: STATUS.completed,\n    type: event.Cheque.invoice.promise.request ? TYPE.request : TYPE.offer, // this indicates the original event type (eg. 'I requested hf from you', 'You sent a offer to me', etc.)\n    timestamp: eventTimestamp,\n    fees,\n    presentBalance,\n    notes: event.Cheque.invoice.promise.tx.notes\n  }\n}\n\nfunction presentPendingRequest (transaction) {\n  const { event, provenance } = transaction\n  const origin = event[0]\n  const stateDirection = DIRECTION.incoming // this indicates the recipient of funds\n  const eventTimestamp = event[1]\n  const counterparty = provenance[0]\n  const { amount, notes, fee } = event[2].Request\n  return presentRequest({ origin, stateDirection, eventTimestamp, counterparty, amount, notes, fees: fee })\n}\n\nfunction presentPendingOffer (transaction) {\n  const { event, provenance } = transaction\n  const origin = event[2].Promise.request ? event[2].Promise.request : event[0]\n  const stateDirection = DIRECTION.outgoing // this indicates the spender of funds\n  const eventTimestamp = event[1]\n  const counterparty = provenance[0]\n  const { amount, notes, fee } = event[2].Promise.tx\n  return presentOffer({ origin, stateDirection, eventTimestamp, counterparty, amount, notes, fees: fee })\n}\n\nfunction presentTransaction (transaction) {\n  const { state, origin, event, timestamp, adjustment } = transaction\n  const stateStage = state.split('/')[1]\n  const stateDirection = state.split('/')[0] // NOTE: This returns either 'incoming' or 'outgoing,' wherein, 'incoming' indicates the recipient of funds, 'outgoing' indicates the spender of funds.\n  // NOTE: *Holofuel does NOT yet provide a balance that represents the 'RESULTING ACCT BALANCE after this transaction adjustment', instead of the only the tx adjustment balance or real-time balance.*\n  const parsedAdjustment = mapValues('Ok', adjustment)\n\n  switch (stateStage) {\n    case 'completed': {\n      if (event.Receipt) return presentReceipt({ origin, event, stateDirection, eventTimestamp: timestamp.event, fees: parsedAdjustment.fees, presentBalance: parsedAdjustment.resulting_balance })\n      if (event.Cheque) return presentCheque({ origin, event, stateDirection, eventTimestamp: timestamp.event, fees: parsedAdjustment.fees, presentBalance: parsedAdjustment.resulting_balance })\n      throw new Error('Completed event did not have a Receipt or Cheque event')\n    }\n    case 'rejected': {\n      // We have decided not to return the reject case into the Ledger\n      break\n    }\n    // The below two cases are 'waitingTransaction' cases :\n    case 'requested': {\n      return presentRequest({ origin, event, stateDirection, eventTimestamp: timestamp.event, fees: parsedAdjustment.fees })\n    }\n    // NOTE: 'approved' only indicates that a payment was offered (could be in response to a request or an isolate payment)\n    case 'approved': {\n      return presentOffer({ origin, event, stateDirection, eventTimestamp: timestamp.event, fees: parsedAdjustment.fees })\n    }\n    default:\n      throw new Error('Error: No transaction stateState was matched. Current transaction stateStage : ', stateStage)\n  }\n}\n\nconst HoloFuelDnaInterface = {\n  user: {\n    get: async ({ agentId }) => {\n      const result = await createZomeCall('transactions/whoami')({ agentId })\n      if (result.error) throw new Error('There was an error locating the agent nickname. ERROR: ', result.error)\n      return {\n        id: result.pub_sign_key,\n        nickname: result.nick\n      }\n    }\n  },\n  ledger: {\n    get: async () => {\n      const { balance, credit, payable, receivable, fees } = await createZomeCall('transactions/ledger_state')()\n      return {\n        balance,\n        credit,\n        payable,\n        receivable,\n        fees\n      }\n    }\n  },\n  transactions: {\n    allCompleted: async () => {\n      const { transactions } = await createZomeCall('transactions/list_transactions')()\n      const listOfNonActionableTransactions = transactions.map(presentTransaction)\n      const noDuplicateIds = _.uniqBy(listOfNonActionableTransactions, 'id')\n      return noDuplicateIds.filter(tx => tx.status === 'completed').sort((a, b) => a.timestamp < b.timestamp ? -1 : 1)\n    },\n    allActionable: async () => {\n      const { requests, promises } = await createZomeCall('transactions/list_pending')()\n      const actionableTransactions = requests.map(presentPendingRequest).concat(promises.map(presentPendingOffer))\n      return actionableTransactions.sort((a, b) => a.timestamp < b.timestamp ? -1 : 1)\n    },\n    allWaiting: async () => {\n      const { transactions } = await createZomeCall('transactions/list_transactions')()\n      const listOfNonActionableTransactions = transactions.map(presentTransaction)\n      // NOTE: Filtering out duplicate IDs should prevent an already completed tranaction from displaying as a pending tranaction if any lag occurs in data update layer.\n      const noDuplicateIds = _.uniqBy(listOfNonActionableTransactions, 'id')\n      return noDuplicateIds.filter(tx => tx.status === 'pending').sort((a, b) => a.timestamp < b.timestamp ? -1 : 1)\n    },\n    getSinglePending: async transactionId => {\n      const { requests, promises } = await createZomeCall('transactions/list_pending')({ origins: transactionId })\n      const transactionArray = requests.map(presentPendingRequest).concat(promises.map(presentPendingOffer))\n      if (transactionArray.length === 0) {\n        throw new Error(`no pending transaction with id ${transactionId} found.`)\n      } else {\n        return transactionArray[0]\n      }\n    },\n    // decline pending proposed transaction (NB: proposed by another agent).\n    decline: async transactionId => {\n      const transaction = await HoloFuelDnaInterface.transactions.getSinglePending(transactionId)\n      await createZomeCall('transactions/decline')({ origin: transactionId })\n      return {\n        ...transaction,\n        id: transactionId,\n        status: STATUS.rejected\n      }\n    },\n    // cancel pending authored transaction.\n    cancel: async transactionId => {\n      const transaction = await HoloFuelDnaInterface.transactions.getSinglePending(transactionId)\n      await createZomeCall('transactions/cancel')({ origin: transactionId })\n      return {\n        ...transaction,\n        id: transactionId,\n        status: STATUS.cancelled\n      }\n    }\n  },\n  requests: {\n    create: async (counterparty, amount) => {\n      const origin = await createZomeCall('transactions/request')({ from: counterparty, amount, deadline: MOCK_DEADLINE })\n      return {\n        id: origin,\n        amount,\n        counterparty,\n        direction: DIRECTION.incoming, // this indicates the hf recipient\n        status: STATUS.pending,\n        type: TYPE.request,\n        timestamp: currentDataTimeIso\n      }\n    }\n  },\n  offers: {\n    create: async (counterparty, amount, requestId) => {\n      const origin = await createZomeCall('transactions/promise')({ to: counterparty, amount, deadline: MOCK_DEADLINE, requestId })\n      return {\n        id: requestId || origin, // NOTE: If requestId isn't defined, then offer use origin as the ID (ie. Offer is the initiating transaction).\n        amount,\n        counterparty,\n        direction: DIRECTION.outgoing, // this indicates the hf spender\n        status: STATUS.pending,\n        type: TYPE.offer,\n        timestamp: currentDataTimeIso\n      }\n    },\n\n    accept: async (transactionId) => {\n      const transaction = await HoloFuelDnaInterface.transactions.getSinglePending(transactionId)\n      await createZomeCall('transactions/receive_payments_pending')({ promises: transactionId })\n      console.log('ACCEPT PAYMENT TRANSACTION OBJECT : ', transaction)\n      return {\n        ...transaction,\n        id: transactionId,\n        // direction: DIRECTION.incoming, // this indicates the hf recipient\n        status: STATUS.completed // ,\n        // type: TYPE.offer\n      }\n    }\n  }\n}\n\nexport default HoloFuelDnaInterface\n"]},"metadata":{},"sourceType":"module"}