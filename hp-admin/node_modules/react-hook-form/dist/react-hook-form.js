'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

var isCheckBoxInput = (type) => type === 'checkbox';

function attachEventListeners({ field, validateAndStateUpdate, isRadio, }) {
    const { ref } = field;
    if (!ref.addEventListener)
        return;
    ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? 'change' : 'input', validateAndStateUpdate);
    ref.addEventListener('blur', validateAndStateUpdate);
}

var isUndefined = (val) => val === undefined;

var isNullOrUndefined = (value) => value === null || isUndefined(value);

var isObject = (value) => !isNullOrUndefined(value) &&
    !Array.isArray(value) &&
    typeof value === 'object';

const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
const reEscapeChar = /\\(\\)?/g;
const reIsUint = /^(?:0|[1-9]\d*)$/;
const isArray = Array.isArray;
function isIndex(value) {
    return reIsUint.test(value) && value > -1;
}
function isKey(value) {
    if (isArray(value))
        return false;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);
}
const stringToPath = (string) => {
    const result = [];
    string.replace(rePropName, (match, number, quote, string) => {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
};
function set(object, path, value) {
    const tempPath = isKey(path) ? [path] : stringToPath(path);
    let index = -1;
    const length = tempPath.length;
    const lastIndex = length - 1;
    while (++index < length) {
        const key = tempPath[index];
        let newValue = value;
        if (index !== lastIndex) {
            const objValue = object[key];
            newValue =
                isObject(objValue) || isArray(objValue)
                    ? objValue
                    : isIndex(tempPath[index + 1])
                        ? []
                        : {};
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
}

var combineFieldValues = (data) => Object.entries(data).reduce((previous, [key, value]) => {
    if (key.match(/\[\d+\]/gi) || key.indexOf('.')) {
        set(previous, key, value);
        return previous;
    }
    return Object.assign(Object.assign({}, previous), { [key]: value });
}, {});

var removeAllEventListeners = (ref, validateWithStateUpdate) => {
    if (!ref.removeEventListener)
        return;
    ref.removeEventListener('input', validateWithStateUpdate);
    ref.removeEventListener('change', validateWithStateUpdate);
    ref.removeEventListener('blur', validateWithStateUpdate);
};

var isRadioInput = (type) => type === 'radio';

function isDetached(element) {
    if (!element)
        return true;
    if (!(element instanceof HTMLElement) ||
        element.nodeType === Node.DOCUMENT_NODE)
        return false;
    return isDetached(element.parentNode);
}

function findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate = () => { }, field, forceDelete = false) {
    if (!field)
        return;
    const { ref, mutationWatcher, options } = field;
    if (!ref || !ref.type)
        return;
    const { name, type } = ref;
    if (isRadioInput(type) && options) {
        options.forEach(({ ref }, index) => {
            if (options[index] && isDetached(ref) || forceDelete) {
                removeAllEventListeners(options[index], validateWithStateUpdate);
                (options[index].mutationWatcher || { disconnect: () => { } }).disconnect();
                options.splice(index, 1);
            }
        });
        if (!options.length)
            delete fields[name];
    }
    else if (isDetached(ref) || forceDelete) {
        removeAllEventListeners(ref, validateWithStateUpdate);
        if (mutationWatcher)
            mutationWatcher.disconnect();
        delete fields[name];
    }
}

const defaultReturn = {
    isValid: false,
    value: '',
};
function getRadioValue(options) {
    return options && Array.isArray(options)
        ? options.reduce((previous, { ref: { checked, value } }) => checked
            ? {
                isValid: true,
                value,
            }
            : previous, defaultReturn)
        : defaultReturn;
}

var getMultipleSelectValue = (options) => [...options].filter(({ selected }) => selected).map(({ value }) => value);

var isMultipleSelect = (type) => type === 'select-multiple';

function getFieldValue(fields, ref) {
    const { type, name, options, checked, value } = ref;
    if (isRadioInput(type)) {
        const field = fields[name];
        return field ? getRadioValue(field.options).value : '';
    }
    if (isMultipleSelect(type))
        return getMultipleSelectValue(options);
    if (isCheckBoxInput(type)) {
        if (checked) {
            return ref.attributes && ref.attributes.value
                ? isUndefined(value) || value === ''
                    ? true
                    : value
                : true;
        }
        return false;
    }
    return value;
}

var isString = (value) => typeof value === 'string';

function getFieldsValue(fields, fieldName) {
    return Object.values(fields).reduce((previous, { ref, ref: { name } }) => {
        const value = getFieldValue(fields, ref);
        if (isString(fieldName))
            return name === fieldName ? value : previous;
        if (!fieldName) {
            previous[name] = value;
        }
        else if (Array.isArray(fieldName) && fieldName.includes(name)) {
            previous[name] = value;
        }
        return previous;
    }, {});
}

var isEmptyObject = (value) => isObject(value) && Object.keys(value).length === 0;

var isSameError = (error, type, message) => isObject(error) && (error.type === type && error.message === message);

function shouldUpdateWithError({ errors, name, error, isValidateDisabled, }) {
    if (isValidateDisabled ||
        (isEmptyObject(error) && isEmptyObject(errors)) ||
        (errors[name] && errors[name].isManual)) {
        return false;
    }
    if ((isEmptyObject(errors) && !isEmptyObject(error)) ||
        (isEmptyObject(error) && errors[name]) ||
        !errors[name]) {
        return true;
    }
    return (errors[name] &&
        error[name] &&
        !isSameError(errors[name], error[name].type, error[name].message));
}

var isRegex = (value) => value instanceof RegExp;

var getValueAndMessage = (validationData) => ({
    value: isObject(validationData) &&
        !isRegex(validationData) &&
        !isNullOrUndefined(validationData.value)
        ? validationData.value
        : validationData,
    message: isObject(validationData) &&
        !(validationData instanceof RegExp) &&
        validationData.message
        ? validationData.message
        : '',
});

var displayNativeError = (nativeValidation, ref, message) => {
    if (nativeValidation && isString(message))
        ref.setCustomValidity(message);
};

const DATE_INPUTS = [
    'date',
    'time',
    'month',
    'datetime',
    'datetime-local',
    'week',
];
const STRING_INPUTS = [
    'text',
    'email',
    'password',
    'search',
    'tel',
    'url',
    'textarea',
];
const VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
};

var isFunction = (value) => typeof value === 'function';

var isBoolean = (value) => typeof value === 'boolean';

var validateField = async ({ ref, ref: { type, value, name, checked }, options, required, maxLength, minLength, min, max, pattern, validate, }, fields, nativeValidation) => {
    const error = {};
    const isRadio = isRadioInput(type);
    const isCheckBox = isCheckBoxInput(type);
    const isSelectOrInput = !isCheckBox && !isRadio;
    const nativeError = displayNativeError.bind(null, nativeValidation, ref);
    const isStringInput = STRING_INPUTS.includes(type) || isString(value);
    if (required &&
        ((isCheckBox && !checked) ||
            (isSelectOrInput && value === '') ||
            (isRadio && !getRadioValue(fields[name].options).isValid) ||
            (!type && !value))) {
        error[name] = {
            type: 'required',
            message: isString(required) ? required : '',
            ref: isRadio ? (fields[name].options || [{ ref: '' }])[0].ref : ref,
        };
        nativeError(required);
        return error;
    }
    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {
        let exceedMax;
        let exceedMin;
        const valueNumber = parseFloat(value);
        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);
        const { value: minValue, message: minMessage } = getValueAndMessage(min);
        if (type === 'number' || !isNaN(value)) {
            exceedMax = !isNullOrUndefined(maxValue) && valueNumber > maxValue;
            exceedMin = !isNullOrUndefined(minValue) && valueNumber < minValue;
        }
        else if (DATE_INPUTS.includes(type) || type === undefined) {
            if (isString(maxValue))
                exceedMax = maxValue && new Date(value) > new Date(maxValue);
            if (isString(minValue))
                exceedMin = minValue && new Date(value) < new Date(minValue);
        }
        if (exceedMax || exceedMin) {
            const message = exceedMax ? maxMessage : minMessage;
            error[name] = {
                type: exceedMax ? 'max' : 'min',
                message,
                ref,
            };
            nativeError(message);
            return error;
        }
    }
    if ((maxLength || minLength) && isStringInput) {
        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);
        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);
        const inputLength = value.toString().length;
        const exceedMax = maxLength && inputLength > maxLengthValue;
        const exceedMin = inputLength && minLength && inputLength < minLengthValue;
        const message = exceedMax ? maxLengthMessage : minLengthMessage;
        if (exceedMax || exceedMin) {
            error[name] = {
                type: exceedMax ? 'maxLength' : 'minLength',
                message,
                ref,
            };
            nativeError(message);
            return error;
        }
    }
    if (pattern) {
        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);
        if (isRegex(patternValue) && !patternValue.test(value)) {
            error[name] = {
                type: 'pattern',
                message: patternMessage,
                ref,
            };
            nativeError(patternMessage);
            return error;
        }
    }
    if (validate) {
        const fieldValue = getFieldValue(fields, ref);
        const validateRef = isRadio && options ? options[0].ref : ref;
        if (isFunction(validate)) {
            const result = await validate(fieldValue);
            if ((isString(result) && result) || (isBoolean(result) && !result)) {
                error[name] = {
                    type: 'validate',
                    message: isString(result) ? result : '',
                    ref: validateRef,
                };
                nativeError(result);
                return error;
            }
        }
        else if (isObject(validate)) {
            const validationResult = await new Promise((resolve) => {
                const values = Object.entries(validate);
                values.reduce(async (previous, [key, validate], index) => {
                    const lastChild = values.length - 1 === index;
                    if (isFunction(validate)) {
                        const result = await validate(fieldValue);
                        if (!isBoolean(result) || !result) {
                            const message = isString(result) ? result : '';
                            const data = {
                                type: key,
                                message,
                                ref: validateRef,
                            };
                            nativeError(message);
                            return lastChild ? resolve(data) : data;
                        }
                    }
                    return lastChild ? resolve(previous) : previous;
                }, {});
            });
            if (validationResult && !isEmptyObject(validationResult)) {
                error[name] = Object.assign({ ref: validateRef }, validationResult);
                return error;
            }
        }
    }
    if (nativeValidation)
        ref.setCustomValidity('');
    return error;
};

function parseErrorSchema(error) {
    return error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), { [path]: { message, ref: {}, type } })), {});
}
async function validateWithSchema(validationSchema, validateWithSchema, data) {
    try {
        return {
            result: await validationSchema.validate(data, validateWithSchema),
            fieldErrors: {},
        };
    }
    catch (e) {
        return {
            fieldErrors: parseErrorSchema(e),
            result: {},
        };
    }
}

function attachNativeValidation(ref, rules) {
    Object.entries(rules).forEach(([key, value]) => {
        if (key === 'pattern' && isRegex(value)) {
            ref[key] = value.source;
        }
        else {
            ref[key] = key === 'required' ? true : value;
        }
    });
}

function get(object, keys, defaultVal) {
    keys = Array.isArray(keys)
        ? keys
        : keys
            .replace(/\[/g, '.')
            .replace(/\]/g, '')
            .split('.');
    object = object[keys[0]];
    return object && keys.length > 1
        ? get(object, keys.slice(1), defaultVal)
        : isUndefined(object)
            ? defaultVal
            : object;
}

function getDefaultValue(defaultValues, name, defaultValue) {
    return isUndefined(defaultValues[name])
        ? get(defaultValues, name, defaultValue)
        : defaultValues[name];
}

function flatArray(list) {
    return list.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}

const getPath = (path, values) => Array.isArray(values)
    ? values.map((item, index) => {
        const pathWithIndex = `${path}[${index}]`;
        if (Array.isArray(item)) {
            return getPath(pathWithIndex, item);
        }
        else if (isObject(item)) {
            return Object.entries(item).map(([key, objectValue]) => isString(objectValue)
                ? `${pathWithIndex}.${key}`
                : getPath(`${pathWithIndex}.${key}`, objectValue));
        }
        return pathWithIndex;
    })
    : Object.entries(values).map(([key, objectValue]) => isString(objectValue) ? `${path}.${key}` : getPath(path, objectValue));
var getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));

var assignWatchFields = (fieldValues, fieldName, watchFields) => {
    if (isEmptyObject(fieldValues) || isUndefined(fieldValues))
        return undefined;
    if (!isUndefined(fieldValues[fieldName])) {
        watchFields[fieldName] = true;
        return fieldValues[fieldName];
    }
    const values = get(combineFieldValues(fieldValues), fieldName);
    if (values !== undefined) {
        const result = getPath$1(fieldName, values);
        if (Array.isArray(result)) {
            result.forEach(name => {
                watchFields[name] = true;
            });
        }
    }
    return values;
};

var omitValidFields = (errorFields, validFieldNames) => Object.entries(errorFields).reduce((previous, [name, error]) => validFieldNames.some(validFieldName => validFieldName === name)
    ? previous
    : Object.assign(Object.assign({}, previous), { [name]: error }), {});

var isArray$1 = (value) => Array.isArray(value);

function onDomRemove(element, onDetachCallback) {
    const observer = new MutationObserver(() => {
        if (isDetached(element)) {
            observer.disconnect();
            onDetachCallback();
        }
    });
    observer.observe(window.document, {
        childList: true,
        subtree: true,
    });
    return observer;
}

var modeChecker = (mode) => ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
});

function useForm({ mode = VALIDATION_MODE.onSubmit, validationSchema, defaultValues = {}, validationFields, nativeValidation, submitFocusError = true, validationSchemaOption = { abortEarly: false }, } = {}) {
    const fieldsRef = React.useRef({});
    const errorsRef = React.useRef({});
    const schemaErrorsRef = React.useRef({});
    const submitCountRef = React.useRef(0);
    const touchedFieldsRef = React.useRef(new Set());
    const watchFieldsRef = React.useRef({});
    const dirtyFieldsRef = React.useRef(new Set());
    const fieldsWithValidationRef = React.useRef(new Set());
    const validFieldsRef = React.useRef(new Set());
    const defaultValuesRef = React.useRef({});
    const isUnMount = React.useRef(false);
    const isWatchAllRef = React.useRef(false);
    const isSubmittingRef = React.useRef(false);
    const isSubmittedRef = React.useRef(false);
    const isDirtyRef = React.useRef(false);
    const isSchemaValidateTriggeredRef = React.useRef(false);
    const validationFieldsRef = React.useRef(validationFields);
    const validateAndStateUpdateRef = React.useRef();
    const [, reRenderForm] = React.useState({});
    const { isOnChange, isOnBlur, isOnSubmit } = React.useRef(modeChecker(mode)).current;
    const validateWithSchemaCurry = React.useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOption), []);
    validationFieldsRef.current = validationFields;
    const combineErrorsRef = (data) => (Object.assign(Object.assign({}, errorsRef.current), data));
    const renderBaseOnError = React.useCallback((name, error, shouldRender = true) => {
        if (errorsRef.current[name] && !error[name]) {
            delete errorsRef.current[name];
            if (fieldsWithValidationRef.current.has(name))
                validFieldsRef.current.add(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        if (error[name]) {
            validFieldsRef.current.delete(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        if (!isOnSubmit &&
            fieldsWithValidationRef.current.has(name) &&
            !validFieldsRef.current.has(name)) {
            validFieldsRef.current.add(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        return false;
    }, [isOnSubmit]);
    const setFieldValue = (name, value) => {
        const field = fieldsRef.current[name];
        if (!field)
            return;
        const ref = field.ref;
        const options = field.options;
        const { type } = ref;
        if (isRadioInput(type) && options) {
            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));
        }
        else if (isMultipleSelect(type)) {
            [...ref.options].forEach(selectRef => (selectRef.selected = value.includes(selectRef.value)));
        }
        else {
            ref[isCheckBoxInput(type) ? 'checked' : 'value'] = value;
        }
    };
    const setDirty = (name) => {
        if (!fieldsRef.current[name])
            return false;
        const isDirty = defaultValuesRef.current[name] !==
            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);
        const isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;
        if (isDirty) {
            dirtyFieldsRef.current.add(name);
        }
        else {
            dirtyFieldsRef.current.delete(name);
        }
        isDirtyRef.current = !!dirtyFieldsRef.current.size;
        return isDirtyChanged;
    };
    const setValueInternal = React.useCallback((name, value) => {
        setFieldValue(name, value);
        touchedFieldsRef.current.add(name);
        setDirty(name);
        reRenderForm({});
    }, []);
    const executeValidation = React.useCallback(async ({ name, value, }, shouldRender = true) => {
        const field = fieldsRef.current[name];
        if (!field)
            return false;
        if (value !== undefined)
            setValueInternal(name, value);
        const error = await validateField(field, fieldsRef.current);
        errorsRef.current = combineErrorsRef(error);
        renderBaseOnError(name, error, shouldRender);
        return isEmptyObject(error);
    }, [renderBaseOnError, setValueInternal]);
    const executeSchemaValidation = React.useCallback(async (payload) => {
        const { fieldErrors } = await validateWithSchemaCurry(combineFieldValues(getFieldsValue(fieldsRef.current)));
        const names = isArray$1(payload)
            ? payload.map(({ name }) => name)
            : [payload.name];
        const validFieldNames = names.filter(name => !fieldErrors[name]);
        schemaErrorsRef.current = fieldErrors;
        errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors)
            .filter(([key]) => names.includes(key))
            .reduce((previous, [name, error]) => (Object.assign(Object.assign({}, previous), { [name]: error })), {})), validFieldNames);
        isSchemaValidateTriggeredRef.current = true;
        reRenderForm({});
        return isEmptyObject(errorsRef.current);
    }, [validateWithSchemaCurry]);
    const triggerValidation = React.useCallback(async (payload) => {
        const fields = payload || Object.keys(fieldsRef.current).map(name => ({ name }));
        if (validationSchema)
            return executeSchemaValidation(fields);
        if (isArray$1(fields)) {
            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, false)));
            reRenderForm({});
            return result.every(Boolean);
        }
        return await executeValidation(fields);
    }, [executeSchemaValidation, executeValidation, validationSchema]);
    const setValue = React.useCallback((name, value, shouldValidate = false) => {
        setValueInternal(name, value);
        if (shouldValidate)
            return triggerValidation({ name });
    }, [setValueInternal, triggerValidation]);
    validateAndStateUpdateRef.current = validateAndStateUpdateRef.current
        ? validateAndStateUpdateRef.current
        : async ({ target: { name }, type }) => {
            if (isArray$1(validationFieldsRef.current) &&
                !validationFieldsRef.current.includes(name))
                return;
            const fields = fieldsRef.current;
            const errors = errorsRef.current;
            const ref = fields[name];
            if (!ref)
                return;
            const isBlurEvent = type === 'blur';
            const isValidateDisabled = !isSubmittedRef.current && isOnSubmit;
            const shouldUpdateValidateMode = isOnChange || (isOnBlur && isBlurEvent) || errors[name];
            let shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current[name];
            if (setDirty(name)) {
                shouldUpdateState = true;
            }
            if (!touchedFieldsRef.current.has(name)) {
                touchedFieldsRef.current.add(name);
                shouldUpdateState = true;
            }
            if (isValidateDisabled)
                return shouldUpdateState ? reRenderForm({}) : undefined;
            if (validationSchema) {
                const { fieldErrors } = await validateWithSchemaCurry(combineFieldValues(getFieldsValue(fields)));
                schemaErrorsRef.current = fieldErrors;
                isSchemaValidateTriggeredRef.current = true;
                const error = fieldErrors[name];
                const shouldUpdate = ((!error && errors[name]) || error) &&
                    (shouldUpdateValidateMode || isSubmittedRef.current);
                if (shouldUpdate) {
                    errorsRef.current = Object.assign(Object.assign({}, errors), { [name]: error });
                    if (!error)
                        delete errorsRef.current[name];
                    return reRenderForm({});
                }
            }
            else {
                const error = await validateField(ref, fields, nativeValidation);
                const shouldUpdate = shouldUpdateWithError({
                    errors: errors,
                    error,
                    isValidateDisabled,
                    name,
                });
                if (shouldUpdate || shouldUpdateValidateMode) {
                    errorsRef.current = combineErrorsRef(error);
                    if (renderBaseOnError(name, error))
                        return;
                }
            }
            if (shouldUpdateState)
                reRenderForm({});
        };
    const resetFieldRef = (name) => {
        delete watchFieldsRef.current[name];
        delete errorsRef.current[name];
        delete fieldsRef.current[name];
        delete defaultValuesRef.current[name];
        [
            touchedFieldsRef,
            dirtyFieldsRef,
            fieldsWithValidationRef,
            validFieldsRef,
        ].forEach(data => data.current.delete(name));
    };
    const removeEventListenerAndRef = React.useCallback((field, forceDelete) => {
        if (!field)
            return;
        findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndStateUpdateRef.current, field, forceDelete);
        resetFieldRef(field.ref.name);
    }, []);
    function clearError(name) {
        if (isString(name)) {
            delete errorsRef.current[name];
        }
        else if (isArray$1(name)) {
            name.forEach(fieldName => delete errorsRef.current[fieldName]);
        }
        else {
            errorsRef.current = {};
        }
        reRenderForm({});
    }
    const setError = (name, type, message, ref) => {
        const errors = errorsRef.current;
        const error = errors[name];
        if (!isSameError(error, type, message)) {
            errors[name] = {
                type,
                message,
                ref,
                isManual: true,
            };
            reRenderForm({});
        }
    };
    function watch(fieldNames, defaultValue) {
        const fieldValues = getFieldsValue(fieldsRef.current);
        const watchFields = watchFieldsRef.current;
        if (isString(fieldNames)) {
            const value = assignWatchFields(fieldValues, fieldNames, watchFields);
            return !isUndefined(value)
                ? value
                : isUndefined(defaultValue)
                    ? getDefaultValue(defaultValues, fieldNames)
                    : defaultValue;
        }
        if (isArray$1(fieldNames)) {
            return fieldNames.reduce((previous, name) => {
                let value = getDefaultValue(defaultValues, name);
                if (isEmptyObject(fieldsRef.current) &&
                    !isUndefined(defaultValue) &&
                    !isString(defaultValue)) {
                    value = defaultValue[name];
                }
                else {
                    const tempValue = assignWatchFields(fieldValues, name, watchFields);
                    if (!isUndefined(tempValue))
                        value = tempValue;
                }
                return Object.assign(Object.assign({}, previous), { [name]: value });
            }, {});
        }
        isWatchAllRef.current = true;
        return ((!isEmptyObject(fieldValues) && fieldValues) ||
            defaultValue ||
            defaultValues);
    }
    function __registerIntoFieldsRef(ref, validateOptions = {}) {
        if (!ref.name)
            return console.warn('Miss ref', ref);
        const { name, type, value } = ref;
        const { required, validate } = validateOptions;
        const fieldAttributes = Object.assign({ ref }, validateOptions);
        const fields = fieldsRef.current;
        const isRadio = isRadioInput(type);
        const currentField = fields[name];
        const isRegistered = isRadio
            ? currentField &&
                isArray$1(currentField.options) &&
                currentField.options.find(({ ref }) => value === ref.value)
            : currentField;
        if (isRegistered)
            return;
        if (!type) {
            fields[name] = fieldAttributes;
        }
        else {
            const mutationWatcher = onDomRemove(ref, () => removeEventListenerAndRef(fieldAttributes));
            if (isRadio) {
                if (!currentField)
                    fields[name] = {
                        options: [],
                        required,
                        validate,
                        ref: { type: 'radio', name },
                    };
                if (validate)
                    fields[name].validate = validate;
                fields[name].options.push(Object.assign(Object.assign({}, fieldAttributes), { mutationWatcher }));
            }
            else {
                fields[name] = Object.assign(Object.assign({}, fieldAttributes), { mutationWatcher });
            }
        }
        if (!isEmptyObject(defaultValues)) {
            const defaultValue = getDefaultValue(defaultValues, name);
            if (!isUndefined(defaultValue))
                setFieldValue(name, defaultValue);
        }
        if (!isOnSubmit && validateOptions && !isEmptyObject(validateOptions)) {
            fieldsWithValidationRef.current.add(name);
            if (validationSchema) {
                isSchemaValidateTriggeredRef.current = true;
                validateWithSchemaCurry(combineFieldValues(getFieldsValue(fields))).then(({ fieldErrors }) => {
                    schemaErrorsRef.current = fieldErrors;
                    if (isEmptyObject(schemaErrorsRef.current))
                        reRenderForm({});
                });
            }
            else {
                validateField(fields[name], fields).then(error => {
                    if (isEmptyObject(error))
                        validFieldsRef.current.add(name);
                    if (validFieldsRef.current.size === fieldsWithValidationRef.current.size)
                        reRenderForm({});
                });
            }
        }
        if (!defaultValuesRef.current[name])
            defaultValuesRef.current[name] = getFieldValue(fields, fields[name].ref);
        if (!type)
            return;
        const field = isRadio
            ? fields[name].options[fields[name].options.length - 1]
            : fields[name];
        if (nativeValidation && validateOptions) {
            attachNativeValidation(ref, validateOptions);
        }
        else {
            attachEventListeners({
                field,
                isRadio,
                validateAndStateUpdate: validateAndStateUpdateRef.current,
            });
        }
    }
    function register(refOrValidateRule, validationOptions) {
        if (typeof window === 'undefined' || !refOrValidateRule)
            return;
        if (isObject(refOrValidateRule) &&
            (validationOptions || 'name' in refOrValidateRule)) {
            __registerIntoFieldsRef(refOrValidateRule, validationOptions);
            return;
        }
        return (ref) => ref && __registerIntoFieldsRef(ref, refOrValidateRule);
    }
    function unregister(names) {
        if (isEmptyObject(fieldsRef.current))
            return;
        (isArray$1(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));
    }
    const handleSubmit = (callback) => async (e) => {
        if (e) {
            e.preventDefault();
            e.persist();
        }
        let fieldErrors;
        let fieldValues;
        let firstFocusError = true;
        const fields = fieldsRef.current;
        const fieldsToValidate = validationFields
            ? validationFields.map(name => fieldsRef.current[name])
            : Object.values(fields);
        isSubmittingRef.current = true;
        reRenderForm({});
        if (validationSchema) {
            fieldValues = getFieldsValue(fields);
            const output = await validateWithSchema(validationSchema, validationSchemaOption, combineFieldValues(fieldValues));
            schemaErrorsRef.current = output.fieldErrors;
            fieldErrors = output.fieldErrors;
            fieldValues = output.result;
        }
        else {
            const { errors, values, } = await fieldsToValidate.reduce(async (previous, field) => {
                if (!field)
                    return previous;
                const resolvedPrevious = await previous;
                const { ref, ref: { name, focus }, } = field;
                if (!fields[name])
                    return Promise.resolve(resolvedPrevious);
                const fieldError = await validateField(field, fields, nativeValidation);
                if (fieldError[name]) {
                    if (submitFocusError && firstFocusError && focus) {
                        ref.focus();
                        firstFocusError = false;
                    }
                    resolvedPrevious.errors = Object.assign(Object.assign({}, resolvedPrevious.errors), fieldError);
                    return Promise.resolve(resolvedPrevious);
                }
                resolvedPrevious.values[name] = getFieldValue(fields, ref);
                return Promise.resolve(resolvedPrevious);
            }, Promise.resolve({
                errors: {},
                values: {},
            }));
            fieldErrors = errors;
            fieldValues = values;
        }
        if (isEmptyObject(fieldErrors)) {
            errorsRef.current = {};
            await callback(combineFieldValues(fieldValues), e);
        }
        else {
            errorsRef.current = fieldErrors;
        }
        if (isUnMount.current)
            return;
        isSubmittedRef.current = true;
        submitCountRef.current += 1;
        isSubmittingRef.current = false;
        reRenderForm({});
    };
    const resetRefs = () => {
        errorsRef.current = {};
        schemaErrorsRef.current = {};
        submitCountRef.current = 0;
        touchedFieldsRef.current = new Set();
        watchFieldsRef.current = {};
        dirtyFieldsRef.current = new Set();
        fieldsWithValidationRef.current = new Set();
        validFieldsRef.current = new Set();
        defaultValuesRef.current = {};
        isWatchAllRef.current = false;
        isSubmittedRef.current = false;
        isDirtyRef.current = false;
        isSchemaValidateTriggeredRef.current = false;
    };
    const reset = React.useCallback((values) => {
        const fieldsKeyValue = Object.entries(fieldsRef.current);
        for (let [, value] of fieldsKeyValue) {
            if (value && value.ref && value.ref.closest) {
                try {
                    value.ref.closest('form').reset();
                    break;
                }
                catch (_a) { }
            }
        }
        resetRefs();
        if (values) {
            fieldsKeyValue.forEach(([key]) => setFieldValue(key, getDefaultValue(values, key, '')));
        }
        reRenderForm({});
    }, []);
    const getValues = (payload) => {
        const fieldValues = getFieldsValue(fieldsRef.current);
        const output = payload && payload.nest ? combineFieldValues(fieldValues) : fieldValues;
        return isEmptyObject(output) ? defaultValues : output;
    };
    React.useEffect(() => () => {
        isUnMount.current = true;
        fieldsRef.current &&
            Object.values(fieldsRef.current).forEach((field) => removeEventListenerAndRef(field, true));
    }, [removeEventListenerAndRef]);
    return {
        register: React.useCallback(register, [__registerIntoFieldsRef]),
        unregister: React.useCallback(unregister, [
            unregister,
            removeEventListenerAndRef,
        ]),
        handleSubmit,
        watch,
        reset,
        clearError,
        setError,
        setValue,
        triggerValidation,
        getValues,
        errors: validationFields
            ? Object.keys(errorsRef.current).reduce((previous, key) => (Object.assign(Object.assign({}, previous), (validationFields.includes(key)
                ? { [key]: errorsRef.current[key] }
                : null))), {})
            : errorsRef.current,
        formState: Object.assign({ dirty: isDirtyRef.current, isSubmitted: isSubmittedRef.current, submitCount: submitCountRef.current, touched: [...touchedFieldsRef.current], isSubmitting: isSubmittingRef.current }, (isOnSubmit
            ? {
                isValid: isEmptyObject(errorsRef.current),
            }
            : {
                isValid: validationSchema
                    ? isSchemaValidateTriggeredRef.current &&
                        isEmptyObject(schemaErrorsRef.current)
                    : fieldsWithValidationRef.current.size
                        ? !isEmptyObject(fieldsRef.current) &&
                            validFieldsRef.current.size >=
                                fieldsWithValidationRef.current.size
                        : !isEmptyObject(fieldsRef.current),
            })),
    };
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const FormGlobalContext = React.createContext(null);
function useFormContext() {
    return React.useContext(FormGlobalContext);
}
function FormContext(props) {
    const { children } = props, rest = __rest(props, ["children"]);
    return (React.createElement(FormGlobalContext.Provider, { value: rest }, children));
}

exports.FormContext = FormContext;
exports.default = useForm;
exports.useFormContext = useFormContext;
